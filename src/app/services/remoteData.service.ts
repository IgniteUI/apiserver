import { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { IProduct, IOrderDetails } from '../main/interfaces';

// base URL for the API Server
const BASE_URL = 'http://localhost:8153/api.rsc';
const EMPTY_STRING = '';
// authoken generated by API server for a specific user
const authtoken = '2q3P0o4p9N9a7e2B9f8q';
const HTTP_OPTIONS = {
    headers : new HttpHeaders({
        'x-cdata-authtoken': authtoken
    })
};
const TABLE_PREFIX = 'northwind_dbo_';
const TABLES = { Products: `${TABLE_PREFIX}Products`, Orders: `${TABLE_PREFIX}Orders`, OrderDetails: `${TABLE_PREFIX}OrderDetails` };

@Injectable()
export class RemoteDataService {
    public dateFields = [];

    constructor(private _http: HttpClient) { }

    /**
     * Retrieves only metadata (column names, etc) from a table.
     */
    public getMetadata(tableKey: string): any {
        const tableFullName = TABLES[tableKey];
        return this._http.get(this._buildMetadataUrl(tableFullName), HTTP_OPTIONS)
            .pipe(
                map(data => this.prepareColumnsData(data, tableFullName)),
                catchError(this.handleError)
            );
    }

    /**
     * Retrieves data from specific table.
     * Optionally pass `fields` argument to build the OData $select query
     * Optionally pass `expandRel` argument to build the OData $expand query, which joins a related table to the response.
     * Optionally pass `id` and 'primaryKey' arguments to build $filter query
     */
    public getData(tableKey: string,
        fields?: string[],
        id?: number,
        primaryKey?: string,
        expandRel?: string): Observable<IProduct[] | IOrderDetails[]> {

        const tableFullName = TABLES[tableKey];
        return this._http.get(this.buildDataUrl(tableFullName, fields, id, primaryKey, expandRel), HTTP_OPTIONS)
            .pipe(
                map(response => response['value']),
                map(data => data.map(rec => this.parseDates(rec) )),
                map(data => this.flattenResponseData(data, fields)),
                catchError(this.handleError)
            );
    }

    /**
     * Edit record data for record with same primary key as passed object.
     */
    public editData(tableKey: string, body: IProduct): any {
        const tableFullName = TABLES[tableKey];
        const id = body.ProductID;
        return this._http.put(`${BASE_URL}/${tableFullName}(${id})`, body, HTTP_OPTIONS)
            .pipe(
                catchError(this.handleError)
            );
    }

    /**
     * Adds new record
     */
    public addData(tableKey: string, body: IProduct): any {
        const tableFullName = TABLES[tableKey];
        return this._http.post(`${BASE_URL}/${tableFullName}`, body, HTTP_OPTIONS)
            .pipe(
                catchError(this.handleError)
            );
    }

    /**
     * Deletes record with primary key === index
     */
    public deleteData(tableKey: string, id: string): any {
        const tableFullName = TABLES[tableKey];
        return this._http.delete(`${BASE_URL}/${tableFullName}/${id}`, HTTP_OPTIONS)
            .pipe(
                catchError(this.handleError)
            );
    }

    /**
     * Builds the URL to fetch metadata from, by attaching the `$metadata?@json` parameter to the URL
     */
    private _buildMetadataUrl(table: string): string {
        const baseQueryString = `${BASE_URL}/${table}/$metadata?@json`;
        return baseQueryString;
    }

    /**
     * Builds the URL to fetch data from, attaching all passed arguments for $select and $expand queries
     */
    private buildDataUrl(table: string, fields?: string[], id?: number, primaryKey?: string, expandRel?: string): string {
        let baseQueryString = `${BASE_URL}/${table}?$count=true`;
        let selectQuery = EMPTY_STRING;
        let expandQuery = EMPTY_STRING;
        let filterQuery = EMPTY_STRING;
        let query = EMPTY_STRING;
        let select = EMPTY_STRING;

        if (expandRel) {
            expandQuery = `$expand=${expandRel}`;
        }

        if (fields) {
            fields.forEach((field) => {
                if (field !== EMPTY_STRING) {
                    select += `${field}, `;
                }
            });
            if (expandRel) {
                select += `${expandRel}`;
            }
            selectQuery = `$select=${select}`;
        }

        if (id && primaryKey) {
            filterQuery = `($filter=${primaryKey} eq ${id})`;
        }

        query += (selectQuery !== EMPTY_STRING) ? `&${selectQuery}` : EMPTY_STRING;
        query += (expandQuery !== EMPTY_STRING) ? `&${expandQuery}` : EMPTY_STRING;
        query += (filterQuery !== EMPTY_STRING) ? `${filterQuery}` : EMPTY_STRING;

        baseQueryString += query;

        return baseQueryString;
    }

    /**
     * Flatten the joined response from ORDERS and ORDERS_DETAILS tables into a flat object
     */
    private flattenResponseData(data: any[], fields: string[]): any[] {
        if (fields) {
            const dataForProduct = data.map(rec => {
                const detailsDataObj = rec.Details;
                const dataObj = {};
                fields.forEach(f => {
                  dataObj[f] = rec[f];
                });
                return { ...dataObj, ...detailsDataObj};
            });
            return dataForProduct;
        } else {
            return data;
        }
    }

    /**
     * Helper method that normalizes the metadata returned from API Server in format that the grid will build columns
     */
    private prepareColumnsData(data: any, tableFullName: string): any[] {
        const tableMeta = (data as any).items.filter(i => i['odata:table'] === tableFullName)[0];
        const uniqueNames = new Set(tableMeta['odata:cname']);
        const fields = Array.from(uniqueNames);
        const types = tableMeta['odata:cdatatype'];
        const columns = [];

        for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            let type = types[i];
            if (type === 'datetime') {
                type = 'date';
                this.dateFields.push(field);
            }
            if (type === 'int') {
                type = 'number';
            }
            columns.push({ field, type });
        }

        return columns;
    }

    /**
     * Parse ISO DATE string values to Date objects
     */
    private parseDates(rec: IProduct | IOrderDetails): IProduct | IOrderDetails {
        for (const property in rec) {
            if (this.dateFields.indexOf(property) > -1) {
                rec[property] = new Date(rec[property]);
            }
          }

        return rec;
    }

    /**
     * Logs if the server responded with an error.
     */
    private handleError(error: HttpErrorResponse) {
        return throwError(
            'Server is not accesible: ' + error);
    }
}
